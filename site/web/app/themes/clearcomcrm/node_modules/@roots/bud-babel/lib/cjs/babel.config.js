"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = void 0;
const babel_dependencies_1 = require("./babel.dependencies");
/**
 * Babel configuration class
 *
 * @remarks
 * This class is used to configure the Babel transpiler.
 *
 * @example
 * ```ts
 * bud.babel.setPreset(
 *   '@babel/preset-env',
 *   require.resolve('@babel/preset-env'),
 * )
 * ```
 *
 * @public
 */
class Config {
    constructor() {
        /**
         * Plugins registry
         *
         * @public
         */
        this.plugins = {};
        /**
         * Presets registry
         *
         * @public
         */
        this.presets = {};
    }
    /**
     * Set a babel preset
     *
     * @param name - babel preset name
     * @param preset - path to the babel preset or the preset itself
     * @returns The babel configuration class
     *
     * @public
     */
    setPreset(name, preset) {
        if (Array.isArray(preset)) {
            this.presets[name] = preset;
            return this;
        }
        this.presets[name] = [preset];
        return this;
    }
    setPresets(presets) {
        this.presets = Object.entries(presets).reduce((presets, [name, preset]) => {
            if (Array.isArray(preset)) {
                presets[name] = preset;
                return presets;
            }
            presets[name] = [preset];
            return presets;
        }, {});
        return this;
    }
    unsetPreset(preset) {
        this.presets[preset] && delete this.presets[preset];
        return this;
    }
    setPresetOptions(preset, options) {
        this.presets[preset] = [this.presets[preset].shift(), options];
        return this;
    }
    setPlugin(name, plugin) {
        if (Array.isArray(plugin)) {
            this.plugins[name] = plugin;
            return this;
        }
        this.plugins[name] = [plugin];
        return this;
    }
    setPlugins(plugins) {
        this.plugins = Object.entries(plugins).reduce((plugins, [name, plugin]) => {
            if (Array.isArray(plugin)) {
                plugins[name] = plugin;
                return plugins;
            }
            plugins[name] = [plugin];
            return plugins;
        }, {});
        return this;
    }
    unsetPlugin(plugin) {
        this.plugins[plugin] && delete this.plugins[plugin];
        return this;
    }
    setPluginOptions(plugin, options) {
        this.plugins[plugin] = [this.plugins[plugin].shift(), options];
        return this;
    }
}
__decorate([
    babel_dependencies_1.bind
], Config.prototype, "setPreset", null);
__decorate([
    babel_dependencies_1.bind
], Config.prototype, "setPresets", null);
__decorate([
    babel_dependencies_1.bind
], Config.prototype, "unsetPreset", null);
__decorate([
    babel_dependencies_1.bind
], Config.prototype, "setPresetOptions", null);
__decorate([
    babel_dependencies_1.bind
], Config.prototype, "setPlugin", null);
__decorate([
    babel_dependencies_1.bind
], Config.prototype, "setPlugins", null);
__decorate([
    babel_dependencies_1.bind
], Config.prototype, "unsetPlugin", null);
__decorate([
    babel_dependencies_1.bind
], Config.prototype, "setPluginOptions", null);
exports.Config = Config;
